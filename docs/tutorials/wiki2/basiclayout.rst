============
Basic Layout
============

The starter files generated by the ``alchemy`` scaffold are very basic, but
they provide a good orientation for the high-level patterns common to most
:term:`url dispatch` -based :app:`Pyramid` projects.


Application Configuration with ``__init__.py``
----------------------------------------------

File ``tutorial/tutorial/__init__.py`` is used as marker to indicate that its
parent directory is a Python package, and it also defines a ``main()`` function
that creates the :app:`Pyramid` application that will be run.
When you invoke the ``pserve development.ini`` command, the ``main`` function
is executed, passing it some settings, and returns a :term:`WSGI`
application.  (See :ref:`startup_chapter` for more about ``pserve``.)

The content of ``tutorial/tutorial/__init__.py`` is shown below. It starts
by importing some objects needed by the ``main`` function:

 - :meth:`pyramid.config.Configurator` to configure
   the :app:`Pyramid` application.

 - :func:`sqlalchemy.engine_from_config` to create a database engine.

 - :func:`DBSession` and :func:`Base` are used to configure and bind the database of
   the application.

   .. literalinclude:: src/basiclayout/tutorial/__init__.py
      :linenos:
      :language: py


The ``main`` function does the following:

 - :func:`sqlalchemy.engine_from_config` creates a :term:`SQLAlchemy`
   database engine, using from the ``sqlalchemy.`` prefixed
   settings in the ``development.ini`` file's ``[app:main]`` section.
   This will be a URI (something like ``sqlite://``):

 - :meth:`DBSession.configure` initializes our SQLAlchemy session object,
   passing it the engine.

 - :data:`Base.metadata.bind` is assigned the engine we created, initializing
   our SQLAlchemy declarative ``Base`` object.
   This allows table definitions done imperatively
   (instead of declaratively, via a class statement) to work.  We won't use any
   such tables in our application, but if you add one later, long after you've
   forgotten about this tutorial, you won't be left scratching your head when
   it doesn't work.

 - :meth:`pyramid.config.Configurator` is instantiated to construct a
   :term:`Configurator` object.
   The ``settings`` keyword argument gets the dictionary values passed to
   `main()` as the ``**settings`` argument.  This will be a
   dictionary of settings parsed from the ``.ini`` file, which contains
   deployment-related values such as ``pyramid.reload_templates``,
   ``db_string``, etc.

 - :meth:`pyramid.config.Configurator.add_static_view` registers a static
   resource view that will match any URL that starts
   with the prefix ``/static`` (by virtue of the first argument) and
   will serve up static resources for us from within
   the ``static`` directory of our ``tutorial`` package and below
   (by virtue of the second argument).

 - :meth:`pyramid.config.Configurator.add_route` registers a
   :term:`route configuration` for a route named `home` that will be used
   when the URL is ``/``.

 - :meth:`pyramid.config.Configurator.scan` recursively scans the modules
   in our ``tutorial`` package, looking for ``@view_config`` (and
   other special) decorators, registering a view configuration for each
   ``@view_config`` decorator found.  This maps
   application URLs to some code.

 - :meth:`pyramid.config.Configurator.make_wsgi_app` returns a
   :term:`WSGI` application from the :term:`Configurator`.

View Declarations via ``views.py``
----------------------------------

The main function of a web framework is mapping each URL pattern to code (a
:term:`view callable`) that is executed when the requested URL matches the
corresponding :term:`route`. Our application uses the
:meth:`pyramid.view.view_config` decorator to perform this mapping.

Open ``tutorial/tutorial/views.py``.  It should already contain the following:

   .. literalinclude:: src/basiclayout/tutorial/views.py
      :linenos:
      :language: py

The important part here is that the ``@view_config`` decorator associates the
function it decorates (``my_view``) with a :term:`view configuration`, 
consisting of:

   * a ``route_name`` (``home``)
   * a ``renderer``, which is a template from the ``templates`` subdirectory 
     of the package.

When the pattern associated with the ``home`` view is matched during a request,
``my_view()`` will be executed.  ``my_view()`` returns a dictionary; the 
renderer will use the ``templates/mytemplate.pt`` template to create a response
based on the values in the dictionary.

Note that ``my_view()`` accepts a single argument named ``request``.  This is
the standard call signature for a Pyramid :term:`view callable`.

Remember in our ``__init__.py`` when we executed the
:meth:`pyramid.config.Configurator.scan` method, i.e. ``config.scan()``?  The
purpose of calling the scan method was to find and process this
``@view_config`` decorator in order to create a view configuration within our
application.  Without being processed by ``scan``, the decorator effectively
does nothing.  ``@view_config`` is inert without being detected via a
:term:`scan`.

The sample ``my_view()`` created by the scaffold uses a ``try:`` and ``except:``
clause, to detect if there is a problem accessing the project database and
provide an alternate error response.  That response will include the text
shown at the end of the file, which will be displayed in the browser to
inform the user about possible actions to take to solve the problem.

Content Models with ``models.py``
---------------------------------

In a SQLAlchemy-based application, a *model* object is an object composed by
querying the SQL database. The ``models.py`` file is where the ``alchemy``
scaffold put the classes that implement our models.

Open ``tutorial/tutorial/models.py``.  It should already contain the following:

   .. literalinclude:: src/basiclayout/tutorial/models.py
      :linenos:
      :language: py

Let's examine this in detail. First, we need some imports to support later code:

   .. literalinclude:: src/basiclayout/tutorial/models.py
      :end-before: DBSession
      :linenos:
      :language: py

Next we set up a SQLAlchemy ``DBSession`` object:

   .. literalinclude:: src/basiclayout/tutorial/models.py
      :lines: 16
      :language: py

``scoped_session`` and ``sessionmaker`` are standard SQLAlchemy helpers.
``scoped_session`` allows us to access our database connection globally.
``sessionmaker`` creates a database session object.  We pass to
``sessionmaker`` the ``extension=ZopeTransactionExtension()`` extension
option in order to allow the system to automatically manage database
transactions.  With ``ZopeTransactionExtension`` activated, our application
will automatically issue a transaction commit after every request unless an
exception is raised, in which case the transaction will be aborted.

We also need to create a declarative ``Base`` object to use as a
base class for our model:

   .. literalinclude:: src/basiclayout/tutorial/models.py
      :lines: 17
      :language: py

Our model classes will inherit from this ``Base`` class so they can be
associated with our particular database connection.

To give a simple example of a  model class, we define one named ``MyModel``:

   .. literalinclude:: src/basiclayout/tutorial/models.py
      :pyobject: MyModel
      :linenos:
      :language: py

Our example model has an ``__init__`` method that takes two arguments
(``name``, and ``value``).  It stores these values as ``self.name`` and
``self.value`` on the instance created by the ``__init__`` function itself.
The ``MyModel`` class also has a ``__tablename__`` attribute.  This informs
SQLAlchemy which table to use to store the data representing instances of this
class.

That's about all there is to it regarding models, views, and initialization
code in our stock application.
